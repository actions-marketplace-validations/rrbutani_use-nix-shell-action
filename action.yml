name: "use-nix-shell-action"
branding:
  icon: 'cloud-snow'
  color: 'blue'
description: "Apply a nix shell to a GitHub Actions job."
inputs:
  exportEnv:
    description: >
      Boolean indicating whether to export the specified shell's environment
      into your GitHub Actions job's environment.
    required: false
    default: true
  preserveDefaultPath:
    description: >
      Boolean controlling whether the shell's environment *overrides* `$PATH` in
      the job (`false`) or appends to it (`true`). Note that things added to
      `$GITHUB_PATH` (i.e. by other actions) will be preserved regardless.
    required: false
    default: true

  # Shell specification options; set 0 or 1 of these:
  packages:
    description: 'Comma-separated list of packages to install in the shell.'
    required: false
  flakes:
    description: >
      Comma-separated list of flake references to install in the shell.
    required: false
  devShell:
    description: 'Flake path to a devShell.'
    required: false
    # These is the default but we can't mark it as such here because we don't
    # have an easy way to differentiate between defaults and user-provided
    # inputs from within composite (bash) github action implementations.
    #
    # We want to be able to tell the difference between the user actually
    # specifying multiple inputs and the user specifying another shell input +
    # the default for `devShell` coming through.
  file:
    description: 'Path to a file (i.e. shell.nix) describing the shell.'
    required: false


  extraNixOptions:
    description: 'Extra options to pass to the nix invocation used to construct the shell.'
    required: false
    default: ""

# outputs:
#   env:
#         value: ${{ steps.random-number-generator.outputs.random-number }}
# TODO ^

# warn if nix is not installed; go install it

# warn if `pure` is enabled when a script is not provided

# not providing interpreter because the point of running a script is to influence
# the env that's exported; can't do this from within another process..
# so for now, fixed on bash
#
# actually there's no point in providing a script either
#
# pure also doesn't make much sense; most of our shell options use
# `print-dev-env` which doesn't actually run anything or construct an
# environment so we can't really even "run" a script let alone run a script in
# a "pure" shell

runs:
  using: "composite"
  steps:
    - id: check-for-nix
      shell: bash
      run: |
        if ! command nix; then
          echo "nix-missing=true" >> $GITHUB_OUTPUT

          echo '::warning::`nix` not found; installing using `cachix/install-nix-action@v18`'
          {
            echo '## ℹ️ **Note**'
            echo '`nix` was not found so it was installed using [`cachix/install-nix-action`](https://github.com/cachix/install-nix-action)'
            echo ''
            echo 'Consider adding this action to your workflow directly so that you have more control over the nix version/channels/configuration options:'
            echo '```yaml'
            echo ' - uses: cachix/install-nix-action@v18'
            echo '   with:'
            echo '     nix_path: nixpkgs=channel:nixos-unstable'
            echo '```'
          } >> $GITHUB_STEP_SUMMARY

        else
          echo "nix-missing=false" >> $GITHUB_OUTPUT
          echo '::debug::using already present `nix`..'
        fi
    - if: ${{ steps.check-for-nix.outputs.nix-missing == 'true' }}
      uses: cachix/install-nix-action@v18
      with:
        nix_path: nixpkgs=channel:nixos-unstable

    # Point to the vendored `nix-direnv`'s script.
    #
    # We would grab this from `cache.nixos.org` (by store path, for
    # reproducibility) but doing so presents several challenges:
    #   - `nix-direnv` depends on `nix`, etc so it has a large-ish closure size
    #     even though we only really want one function from it
    #   - the derivations technically are system specific (since some of the
    #     deps are) so we'd want to maintain a matrix of store paths here for
    #     the different runner platforms ((linux, macos) x (arch)) so that we
    #     pick the store path that will result in the fewest extra things being
    #     downloaded to the store (it technically doesn't matter if we pull the
    #     "wrong" `nix-direnv` for a platform since we're not actually executing
    #     it; it's just annoying because we'd be pulling in a bunch of binaries
    #     and deps too)
    #
    # So, to keep things fast and simple we just vendored the `nix-direnv`
    # envrc script.
    - run: echo "NIX_DIRENV_PATH='${{ github.action_path }}/vendored/nix-direnv.envrc'" >> $GITHUB_ENV
      shell: bash

    - run: ${{ github.action_path }}/action.bash ${{ github.env }} ${{ github.path }}
      shell: bash
      env:
        INPUT_EXPORT_ENV: ${{ inputs.exportEnv }}
        INPUT_PRESERVE_DEFAULT_PATH: ${{ inputs.preserveDefaultPath }}

        INPUT_PACKAGES: ${{ inputs.packages }}
        INPUT_FLAKES: ${{ inputs.flakes }}
        INPUT_DEVSHELL: ${{ inputs.devShell }}
        INPUT_FILE: ${{ inputs.file }}

        INPUT_EXTRA_NIX_OPTIONS: ${{ inputs.extraNixOptions }}
